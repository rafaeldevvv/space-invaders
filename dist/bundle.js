/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/index.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/index.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `body {\r\n   margin: 0;\r\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://space-invaders/./src/index.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://space-invaders/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://space-invaders/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./src/index.css":
/*!***********************!*\
  !*** ./src/index.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./index.css */ \"./node_modules/css-loader/dist/cjs.js!./src/index.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://space-invaders/./src/index.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://space-invaders/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://space-invaders/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://space-invaders/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://space-invaders/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://space-invaders/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://space-invaders/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__webpack_require__(/*! ./index.css */ \"./src/index.css\");\nconst alienTypes = [\"X\", \"Y\", \"Z\"];\nconst alienTypesRegExp = new RegExp(`(\\\\w*(${alienTypes.join(\"|\")})*\\\\w*)+`);\nconst DIMENSIONS = {\n    alien: {\n        w: 3.5,\n        h: 5,\n    },\n    player: {\n        w: 4,\n        h: 6,\n    },\n    alienSetGap: {\n        w: 1,\n        h: 1.5,\n    },\n    boss: {\n        w: 7,\n        h: 7.5,\n    },\n};\nconst MODEL_LAYOUT = {\n    padding: {\n        hor: 3,\n        ver: 3,\n    },\n    numWalls: 4,\n    wallsSize: {\n        w: 12,\n        h: 10,\n    },\n    playerYPos: 90,\n};\nconst ACTION_KEYS = {\n    moveRight: \"ArrowRight\",\n    moveLeft: \"ArrowLeft\",\n    fire: \" \",\n    startGame: \" \",\n    restartGame: \" \",\n    pauseGame: \"Escape\",\n};\nconst GAME_DISPLAY_SETTINGS = {\n    maxWidth: 920,\n    aspectRatio: 4 / 3,\n};\nconst BOSS_CONFIG = {\n    yPos: 5,\n    speedX: 10,\n    baseAppearanceInterval: 30,\n    score: 150,\n};\nconst basicInvaderPlan = `\r\nZZZZZZZZZZ\r\nYYYYYYYYYY\r\nYYYYYYYYYY\r\nXXXXXXXXXX\r\nXXXXXXXXXX\r\n`;\nconst customWall1 = `\r\n........######################################........\r\n.....############################################.....\r\n...################################################...\r\n..##################################################..\r\n.###################################################..\r\n.############.......##############.......############.\r\n.##########...........##########...........##########.\r\n##########..............######..............##########\r\n#########......##........####.........##.....#########\r\n########......##..........##...........##....#########\r\n########......##.........####..........##.....########\r\n########......###......#########......###.....########\r\n########.......#####..####..######..####......########\r\n########........########......########........########\r\n########.........#####..........#####.........########\r\n#########....................................#########\r\n.#########..................................#########.\r\n..##########..............................##########..\r\n`;\nconst customWall2 = `\r\n...#...............................................#...\r\n..###.............................................###..\r\n..####...........................................####..\r\n.######....................#....................######.\r\n.#######..................###..................#######.\r\n#########................#####................#########\r\n##########..............#######..............##########\r\n############.........#############.........############\r\n##############..#..#################..#..##############\r\n#######################################################\r\n.#####################################################.\r\n...#################################################...\r\n......###########################################......\r\n........###########..................##########........\r\n..........#######......................#######.........\r\n`;\nconst customWall3 = `\r\n............######################################............\r\n.........############################################.........\r\n.......################################################.......\r\n......##################################################......\r\n....####################################################......\r\n....######################################################....\r\n....######################################################....\r\n....######################################################....\r\n....######################################################....\r\n....######################################################....\r\n....######################################################....\r\n....######################################################....\r\n....#############............................#############....\r\n....############..............................############....\r\n....###########................................###########....\r\n...###########..................................###########...\r\n...###########..................................###########...\r\n..#############................................#############..\r\n.###############..............................###############.\r\n##################..........................##################\r\n`;\nclass Vector {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    plus(other) {\n        return new Vector(this.x + other.x, this.y + other.y);\n    }\n    minus(other) {\n        return new Vector(this.x - other.x, this.y - other.y);\n    }\n    times(factor) {\n        return new Vector(this.x * factor, this.y * factor);\n    }\n}\nfunction runAnimation(callback) {\n    let lastTime = null;\n    function frame(time) {\n        let shouldContinue;\n        if (lastTime) {\n            const timeStep = Math.min(time - lastTime, 100) / 1000;\n            lastTime = time;\n            shouldContinue = callback(timeStep);\n        }\n        else {\n            lastTime = time;\n            shouldContinue = true;\n        }\n        if (shouldContinue)\n            requestAnimationFrame(frame);\n    }\n    requestAnimationFrame(frame);\n}\nfunction randomNum(min, max) {\n    return min + Math.random() * (max - min);\n}\nfunction overlap(pos1, size1, pos2, size2) {\n    return (pos1.x + size1.w > pos2.x &&\n        pos1.x < pos2.x + size2.w &&\n        pos1.y + size1.h > pos2.y &&\n        pos1.y < pos2.y + size2.h);\n}\nfunction getElementInnerDimensions(element) {\n    const cs = getComputedStyle(element);\n    const paddingY = parseFloat(cs.paddingBlockStart) + parseFloat(cs.paddingBlockEnd);\n    const paddingX = parseFloat(cs.paddingInlineStart) + parseFloat(cs.paddingInlineEnd);\n    const marginY = parseFloat(cs.marginBlockStart) + parseFloat(cs.marginBlockEnd);\n    const marginX = parseFloat(cs.marginInlineStart) + parseFloat(cs.marginInlineEnd);\n    return {\n        w: element.offsetWidth - paddingX - marginX,\n        h: element.offsetHeight - paddingY - marginY,\n    };\n}\nfunction trackKeys(keys) {\n    const down = {};\n    keys.forEach((key) => (down[key] = false));\n    function onPressKey(e) {\n        for (const key of keys) {\n            if (e.key === key) {\n                e.preventDefault();\n                down[e.key] = e.type === \"keydown\";\n            }\n        }\n    }\n    window.addEventListener(\"keydown\", onPressKey);\n    window.addEventListener(\"keyup\", onPressKey);\n    return down;\n}\nfunction isColumnDead(rows, column) {\n    return rows.every((row) => row[column] === null);\n}\nfunction isRowDead(row) {\n    return row.every((alien) => alien === null);\n}\nfunction getFirstOrLastColumnIfDead(rows) {\n    const isFirstColumnDead = isColumnDead(rows, 0);\n    const isLastColumnDead = isColumnDead(rows, rows[0].length - 1);\n    if (isFirstColumnDead)\n        return 0;\n    if (isLastColumnDead)\n        return rows[0].length - 1;\n    else\n        return null;\n}\nfunction getFirstOrLastRowIfDead(rows) {\n    const isFirstRowDead = isRowDead(rows[0]);\n    const isLastRowDead = isRowDead(rows[rows.length - 1]);\n    if (isFirstRowDead)\n        return 0;\n    if (isLastRowDead)\n        return rows.length - 1;\n    else\n        return null;\n}\nconst alienSetStepToEdgeAdjustment = 1.33;\nconst alienSetTimeDecreaseFactor = 0.92;\nvar HorizontalDirection;\n(function (HorizontalDirection) {\n    HorizontalDirection[HorizontalDirection[\"Right\"] = 1] = \"Right\";\n    HorizontalDirection[HorizontalDirection[\"Left\"] = -1] = \"Left\";\n})(HorizontalDirection || (HorizontalDirection = {}));\nclass AlienSet {\n    constructor(plan) {\n        this.yStep = 3;\n        this.timeToUpdate = 1;\n        this.direction = 1;\n        this.timeStepSum = 0;\n        if (!alienTypesRegExp.test(plan)) {\n            throw new Error(`Invalid character(s) in plan ${plan}. Consider using only valid characters (${alienTypes.join(\",\")})`);\n        }\n        const rows = plan\n            .trim()\n            .split(\"\\n\")\n            .map((l) => [...l]);\n        this.numColumns = rows[0].length;\n        this.numRows = rows.length;\n        this.alive = this.numColumns * this.numRows;\n        const w = this.numColumns * DIMENSIONS.alien.w +\n            (this.numColumns - 1) * DIMENSIONS.alienSetGap.w;\n        const h = this.numRows * DIMENSIONS.alien.h +\n            (this.numRows - 1) * DIMENSIONS.alienSetGap.h;\n        this.size = { w, h };\n        this.pos = new Vector(50 - w / 2, MODEL_LAYOUT.padding.ver + 12);\n        this.xStep = (100 - MODEL_LAYOUT.padding.hor * 2 - w) / 15;\n        this.aliens = rows.map((row, y) => {\n            return row.map((ch, x) => {\n                return Alien.create(ch, { x, y });\n            });\n        });\n    }\n    update(timeStep) {\n        this.timeStepSum += timeStep;\n        const movedY = this.moveVertically();\n        const movedX = this.moveHorizontally(movedY);\n        if (this.timeStepSum >= this.timeToUpdate) {\n            this.timeStepSum = 0;\n        }\n        if (movedY > 0) {\n            this.timeToUpdate *= alienSetTimeDecreaseFactor;\n        }\n        this.pos = this.pos.plus(new Vector(movedX, movedY));\n        for (const alien of this) {\n            if (alien)\n                alien.gun.update(timeStep);\n        }\n    }\n    moveVertically() {\n        let movedY = 0;\n        if (this.pos.x + this.size.w >= 100 - MODEL_LAYOUT.padding.hor &&\n            this.timeStepSum >= this.timeToUpdate &&\n            this.direction === HorizontalDirection.Right) {\n            movedY = this.yStep;\n            this.direction = HorizontalDirection.Left;\n        }\n        else if (this.pos.x <= MODEL_LAYOUT.padding.hor &&\n            this.timeStepSum >= this.timeToUpdate &&\n            this.direction === HorizontalDirection.Left) {\n            movedY = this.yStep;\n            this.direction = HorizontalDirection.Right;\n        }\n        return movedY;\n    }\n    moveHorizontally(movedY) {\n        let movedX = 0;\n        if (this.timeStepSum >= this.timeToUpdate && movedY === 0) {\n            if (this.direction === HorizontalDirection.Right) {\n                const rightDistance = 100 - this.pos.x - MODEL_LAYOUT.padding.hor - this.size.w;\n                if (rightDistance < this.xStep * alienSetStepToEdgeAdjustment) {\n                    movedX = rightDistance;\n                }\n                else {\n                    movedX = this.xStep;\n                }\n            }\n            else {\n                const leftDistance = this.pos.x - MODEL_LAYOUT.padding.hor;\n                if (leftDistance < this.xStep * alienSetStepToEdgeAdjustment) {\n                    movedX = leftDistance;\n                }\n                else {\n                    movedX = this.xStep;\n                }\n            }\n            movedX *= this.direction;\n        }\n        return movedX;\n    }\n    adapt() {\n        this.adaptPos();\n        this.adaptSize();\n        this.removeDeadRowsAndColumns();\n    }\n    adaptSize() {\n        let firstLivingAlienRow = null, lastLivingAlienRow = null, firstLivingAlienColumn = null, lastLivingAlienColumn = null;\n        for (const alien of this) {\n            if (!alien)\n                continue;\n            const { x: column, y: row } = alien.gridPos;\n            if (firstLivingAlienRow === null) {\n                firstLivingAlienRow = row;\n            }\n            lastLivingAlienRow = row;\n            if (firstLivingAlienColumn === null || column < firstLivingAlienColumn) {\n                firstLivingAlienColumn = column;\n            }\n            if (lastLivingAlienColumn === null || column > lastLivingAlienColumn) {\n                lastLivingAlienColumn = column;\n            }\n        }\n        if (firstLivingAlienRow !== null) {\n            const newH = (lastLivingAlienRow - firstLivingAlienRow + 1) * DIMENSIONS.alien.h +\n                (lastLivingAlienRow - firstLivingAlienRow) * DIMENSIONS.alienSetGap.h;\n            const newW = (lastLivingAlienColumn - firstLivingAlienColumn + 1) *\n                DIMENSIONS.alien.w +\n                (lastLivingAlienColumn - firstLivingAlienColumn) *\n                    DIMENSIONS.alienSetGap.w;\n            this.size = {\n                w: newW,\n                h: newH,\n            };\n        }\n    }\n    adaptPos() {\n        let firstLivingAlienColumn = null;\n        let firstLivingAlienRow = null;\n        for (const alien of this) {\n            if (!alien)\n                continue;\n            const { x, y } = alien.gridPos;\n            if (firstLivingAlienColumn === null || x < firstLivingAlienColumn) {\n                firstLivingAlienColumn = x;\n            }\n            if (firstLivingAlienRow === null) {\n                firstLivingAlienRow = y;\n            }\n        }\n        if (firstLivingAlienColumn !== null && firstLivingAlienRow !== null) {\n            this.pos = this.getAlienPos({\n                x: firstLivingAlienColumn,\n                y: firstLivingAlienRow,\n            });\n        }\n    }\n    removeDeadRowsAndColumns() {\n        let columnToRemove;\n        while ((columnToRemove = getFirstOrLastColumnIfDead(this.aliens)) !== null) {\n            this.aliens = this.aliens.map((row) => {\n                return row.filter((_, x) => x !== columnToRemove);\n            });\n            this.syncAliensGridPos();\n        }\n        let rowToRemove;\n        while (this.aliens.length !== 0 &&\n            (rowToRemove = getFirstOrLastRowIfDead(this.aliens)) !== null) {\n            this.aliens = this.aliens.filter((_, y) => y !== rowToRemove);\n            this.syncAliensGridPos();\n        }\n        this.syncNumOfColsAndRows();\n    }\n    syncAliensGridPos() {\n        this.aliens.forEach((row, y) => {\n            row.forEach((alien, x) => {\n                if (alien)\n                    alien.gridPos = { x, y };\n            });\n        });\n    }\n    syncNumOfColsAndRows() {\n        this.numRows = this.aliens.length;\n        this.numColumns = this.numRows === 0 ? 0 : this.aliens[0].length;\n    }\n    getAlienPos({ x, y }) {\n        return new Vector(this.pos.x + x * DIMENSIONS.alien.w + x * DIMENSIONS.alienSetGap.w, this.pos.y + y * DIMENSIONS.alien.h + y * DIMENSIONS.alienSetGap.h);\n    }\n    removeAlien(alien) {\n        this.aliens[alien.gridPos.y][alien.gridPos.x] = null;\n        this.alive--;\n    }\n    *[Symbol.iterator]() {\n        for (let y = 0; y < this.numRows; y++) {\n            for (let x = 0; x < this.numColumns; x++) {\n                yield this.aliens[y][x];\n            }\n        }\n    }\n}\nclass Alien {\n    constructor(gridPos, score, gun, alienType) {\n        this.gridPos = gridPos;\n        this.score = score;\n        this.gun = gun;\n        this.alienType = alienType;\n        this.actorType = \"alien\";\n    }\n    fire(alienPos) {\n        const bulletX = alienPos.x + DIMENSIONS.alien.w / 2 - this.gun.bulletSize.w / 2;\n        return this.gun.fire(new Vector(bulletX, alienPos.y), \"down\");\n    }\n    static create(ch, gridPos) {\n        switch (ch) {\n            case \"X\": {\n                return new Alien(gridPos, 20, new Gun(\"alien\", 40, { w: 0.5, h: 3 }, 4000), ch);\n            }\n            case \"Y\": {\n                return new Alien(gridPos, 40, new Gun(\"alien\", 60, { w: 1, h: 3 }, 6000), ch);\n            }\n            case \"Z\": {\n                return new Alien(gridPos, 60, new Gun(\"alien\", 80, { w: 1.5, h: 3 }, 7000), ch);\n            }\n            case \".\": {\n                return null;\n            }\n            default: {\n                const _never = ch;\n                throw new Error(\"Unexpected character: \" + _never);\n            }\n        }\n    }\n}\nclass Boss {\n    constructor() {\n        this.pos = new Vector(-DIMENSIONS.boss.w, BOSS_CONFIG.yPos);\n    }\n    update(timeStep) {\n        this.pos = this.pos.plus(new Vector(BOSS_CONFIG.speedX * timeStep, 0));\n    }\n}\nconst playerXSpeed = 30;\nclass Player {\n    constructor() {\n        this.actorType = \"player\";\n        this.baseXPos = 50 - DIMENSIONS.player.w / 2;\n        this.pos = new Vector(this.baseXPos, MODEL_LAYOUT.playerYPos);\n        this.gun = new Gun(\"player\", 70, { w: 0.5, h: 3 }, 400);\n        this.lives = 3;\n        this.score = 0;\n    }\n    fire() {\n        const bulletPosX = this.pos.x + DIMENSIONS.player.w / 2 - this.gun.bulletSize.w / 2;\n        return this.gun.fire(new Vector(bulletPosX, this.pos.y), \"up\");\n    }\n    resetPos() {\n        this.pos = new Vector(this.baseXPos, MODEL_LAYOUT.playerYPos);\n    }\n    update(state, timeStep, keys) {\n        const movedX = new Vector(timeStep * playerXSpeed, 0);\n        if (keys[ACTION_KEYS.moveLeft] && this.pos.x > MODEL_LAYOUT.padding.hor) {\n            this.pos = this.pos.minus(movedX);\n        }\n        else if (keys[ACTION_KEYS.moveRight] &&\n            this.pos.x + DIMENSIONS.player.w < 100 - MODEL_LAYOUT.padding.hor) {\n            this.pos = this.pos.plus(movedX);\n        }\n        this.gun.update(timeStep);\n        if (keys[ACTION_KEYS.fire] && this.gun.canFire()) {\n            state.bullets.push(this.fire());\n        }\n    }\n}\nclass Gun {\n    constructor(owner, bulletSpeed, bulletSize, baseFireInterval) {\n        this.owner = owner;\n        this.bulletSpeed = bulletSpeed;\n        this.bulletSize = bulletSize;\n        this.baseFireInterval = baseFireInterval;\n        this.timeSinceLastShot = 0;\n        this.fireInterval = randomNum(0.9 * baseFireInterval, baseFireInterval);\n        this.timeSinceLastShot = randomNum(0, this.fireInterval);\n    }\n    fire(pos, direction) {\n        if (this.canFire()) {\n            this.timeSinceLastShot = 0;\n            this.fireInterval = randomNum(0.9 * this.baseFireInterval, this.baseFireInterval);\n            return new Bullet(this.owner, pos, new Vector(0, direction === \"up\" ? -this.bulletSpeed : this.bulletSpeed), this.bulletSize);\n        }\n        return null;\n    }\n    update(timeStep) {\n        this.timeSinceLastShot += timeStep * 1000;\n    }\n    canFire() {\n        return this.timeSinceLastShot >= this.fireInterval;\n    }\n}\nclass Bullet {\n    constructor(from, pos, speed, size) {\n        this.from = from;\n        this.pos = pos;\n        this.speed = speed;\n        this.size = size;\n    }\n    update(timeStep) {\n        this.pos = this.pos.plus(this.speed.times(timeStep));\n    }\n    collide(state) {\n        state.bullets = state.bullets.filter((bullet) => bullet !== this);\n    }\n}\nclass Wall {\n    constructor(pos, size, numColumnsOrPlan, numRows) {\n        this.pos = pos;\n        this.size = size;\n        let pieces;\n        let pieceSize;\n        if (typeof numColumnsOrPlan === \"string\") {\n            pieces = numColumnsOrPlan\n                .trim()\n                .split(\"\\n\")\n                .map((row) => [...row].map((ch) => ch === \"#\"));\n            pieceSize = {\n                w: this.size.w / pieces[0].length,\n                h: this.size.h / pieces.length,\n            };\n        }\n        else {\n            pieces = new Array(numRows)\n                .fill(undefined)\n                .map(() => new Array(numColumnsOrPlan).fill(true));\n            pieceSize = {\n                w: size.w / numColumnsOrPlan,\n                h: size.h / numRows,\n            };\n        }\n        this.pieceSize = pieceSize;\n        this.piecesMatrix = pieces;\n    }\n    getPiecePos(column, row) {\n        return {\n            x: this.pos.x + column * this.pieceSize.w,\n            y: this.pos.y + row * this.pieceSize.h,\n        };\n    }\n    collide(objPos, objSize) {\n        if (!overlap(this.pos, this.size, objPos, objSize))\n            return false;\n        let touchedPiece = false;\n        for (const { row, column, piece } of this) {\n            if (!piece)\n                continue;\n            const piecePos = this.getPiecePos(column, row);\n            if (overlap(objPos, objSize, piecePos, this.pieceSize)) {\n                this.piecesMatrix[row][column] = false;\n                if (!touchedPiece)\n                    touchedPiece = true;\n            }\n        }\n        return touchedPiece;\n    }\n    *[Symbol.iterator]() {\n        const rows = this.piecesMatrix.length;\n        for (let row = 0; row < rows; row++) {\n            const columnLength = this.piecesMatrix[row].length;\n            for (let column = 0; column < columnLength; column++) {\n                const piece = this.piecesMatrix[row][column];\n                yield { row, column, piece };\n            }\n        }\n    }\n}\nclass GameEnv {\n    constructor(alienSet, player, walls) {\n        this.alienSet = alienSet;\n        this.player = player;\n        this.walls = walls;\n    }\n    isBulletOutOfBounds(bullet) {\n        return bullet.pos.y >= 100 || bullet.pos.y + bullet.size.h <= 0;\n    }\n    alienSetTouchesPlayer() {\n        return this.alienSet.pos.y + this.alienSet.size.h >= this.player.pos.y;\n    }\n    bulletTouchesObject(bullet, objPos, objSize) {\n        return overlap(bullet.pos, bullet.size, objPos, objSize);\n    }\n}\nfunction generateRandomBossAppearanceInterval() {\n    return randomNum(0.8 * BOSS_CONFIG.baseAppearanceInterval, 1.2 * BOSS_CONFIG.baseAppearanceInterval);\n}\nclass GameState {\n    constructor(alienSet, player, env) {\n        this.alienSet = alienSet;\n        this.player = player;\n        this.env = env;\n        this.bullets = [];\n        this.status = \"start\";\n        this.boss = null;\n        this.timeSinceBossLastAppearance = 0;\n        this.bossAppearanceInterval = generateRandomBossAppearanceInterval();\n    }\n    update(timeStep, keys) {\n        if (this.status === \"start\" || this.status === \"lost\")\n            return;\n        this.alienSet.update(timeStep);\n        this.player.update(this, timeStep, keys);\n        this.fireAliens();\n        this.handleBullets(timeStep);\n        this.handleBoss(timeStep);\n        if (this.alienSet.alive === 0) {\n            this.alienSet = new AlienSet(basicInvaderPlan);\n            this.env.alienSet = this.alienSet;\n            this.player.lives++;\n        }\n        else if (this.player.lives < 1 || this.env.alienSetTouchesPlayer()) {\n            this.status = \"lost\";\n        }\n    }\n    handleBullets(timeStep) {\n        this.bullets.forEach((bullet) => bullet.update(timeStep));\n        const newBullets = [];\n        let isSomeAlienKilled = false;\n        for (const b of this.bullets) {\n            const outOfBounds = this.env.isBulletOutOfBounds(b);\n            if (outOfBounds)\n                continue;\n            if (b.from === \"alien\") {\n                const touchedPlayer = this.handleBulletContactWithPlayer(b);\n                if (touchedPlayer)\n                    continue;\n            }\n            else {\n                const touchedAlien = this.handleBulletContactWithAlien(b);\n                const touchedBoss = this.handleBulletContactWithBoss(b);\n                if (!isSomeAlienKilled)\n                    isSomeAlienKilled = touchedAlien;\n                if (touchedAlien || touchedBoss)\n                    continue;\n            }\n            const touchedWall = this.handleBulletContactWithWalls(b);\n            if (touchedWall)\n                continue;\n            newBullets.push(b);\n        }\n        if (isSomeAlienKilled)\n            this.alienSet.adapt();\n        this.bullets = newBullets;\n    }\n    handleBulletContactWithPlayer(b) {\n        if (this.env.bulletTouchesObject(b, this.player.pos, DIMENSIONS.player)) {\n            this.player.lives--;\n            this.player.resetPos();\n            return true;\n        }\n        return false;\n    }\n    handleBulletContactWithAlien(b) {\n        for (const alien of this.alienSet) {\n            if (alien === null)\n                continue;\n            const alienPos = this.alienSet.getAlienPos(alien.gridPos);\n            if (this.env.bulletTouchesObject(b, alienPos, DIMENSIONS.alien)) {\n                this.player.score += alien.score;\n                this.alienSet.removeAlien(alien);\n                return true;\n            }\n        }\n        return false;\n    }\n    handleBulletContactWithWalls(b) {\n        let touchedPiece = false;\n        for (const wall of this.env.walls) {\n            touchedPiece = wall.collide(b.pos, b.size);\n            if (touchedPiece)\n                break;\n        }\n        return touchedPiece;\n    }\n    handleBulletContactWithBoss(b) {\n        if (this.boss === null)\n            return false;\n        if (this.env.bulletTouchesObject(b, this.boss.pos, DIMENSIONS.boss)) {\n            this.player.score += BOSS_CONFIG.score;\n            this.boss = null;\n            this.bossAppearanceInterval = generateRandomBossAppearanceInterval();\n            return true;\n        }\n    }\n    fireAliens() {\n        const newBullets = [];\n        for (const alien of this.alienSet) {\n            if (!alien)\n                continue;\n            if (alien.gun.canFire()) {\n                const alienPos = this.alienSet.getAlienPos(alien.gridPos);\n                const b = alien.fire(alienPos);\n                newBullets.push(b);\n            }\n        }\n        this.bullets.push(...newBullets);\n    }\n    handleBoss(timeStep) {\n        if (this.boss !== null)\n            this.boss.update(timeStep);\n        else\n            this.timeSinceBossLastAppearance += timeStep;\n        if (this.timeSinceBossLastAppearance >= this.bossAppearanceInterval) {\n            this.boss = new Boss();\n            this.timeSinceBossLastAppearance = 0;\n        }\n        if (this.boss && this.boss.pos.x >= 100) {\n            this.boss = null;\n        }\n    }\n    static start(plan) {\n        const alienSet = new AlienSet(plan);\n        const player = new Player();\n        const gap = (100 - MODEL_LAYOUT.wallsSize.w * MODEL_LAYOUT.numWalls) / 5;\n        const walls = new Array(MODEL_LAYOUT.numWalls)\n            .fill(undefined)\n            .map((_, i) => {\n            return new Wall({ x: (i + 1) * gap + MODEL_LAYOUT.wallsSize.w * i, y: 75 }, MODEL_LAYOUT.wallsSize, customWall3);\n        });\n        const env = new GameEnv(alienSet, player, walls);\n        return new GameState(alienSet, player, env);\n    }\n}\nconst alienColors = {\n    X: \"limegreen\",\n    Y: \"orange\",\n    Z: \"pink\",\n};\nclass CanvasView {\n    constructor(state, controller, parent) {\n        this.state = state;\n        this.controller = controller;\n        this.parent = parent;\n        this.canvasFontFamily = \"monospace\";\n        this.trackedKeys = {};\n        this.keysHandlers = new Map();\n        this.canvas = document.createElement(\"canvas\");\n        this.canvasContext = this.canvas.getContext(\"2d\");\n        this.canvas.style.display = \"block\";\n        this.canvas.style.marginInline = \"auto\";\n        this.parent.appendChild(this.canvas);\n        this.defineEventListeners();\n        this.setDisplaySize();\n        this.syncState(state, 0);\n    }\n    setDisplaySize() {\n        let canvasWidth = Math.min(GAME_DISPLAY_SETTINGS.maxWidth, getElementInnerDimensions(this.canvas.parentNode).w);\n        let canvasHeight = canvasWidth / GAME_DISPLAY_SETTINGS.aspectRatio;\n        if (canvasHeight > innerHeight) {\n            canvasHeight = innerHeight;\n            canvasWidth = canvasHeight * GAME_DISPLAY_SETTINGS.aspectRatio;\n        }\n        this.canvas.setAttribute(\"width\", canvasWidth.toString());\n        this.canvas.setAttribute(\"height\", canvasHeight.toString());\n        this.syncState(this.state, 0);\n    }\n    syncState(state, timeStep) {\n        this.canvasContext.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n        this.canvasContext.fillStyle = \"black\";\n        this.canvasContext.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n        switch (state.status) {\n            case \"paused\":\n            case \"running\": {\n                this.drawRunningGame(state, timeStep);\n                break;\n            }\n            case \"start\": {\n                this.drawInitialScreen();\n                break;\n            }\n            case \"lost\": {\n                this.drawGameOverScreen();\n                break;\n            }\n            default: {\n                const _never = state.status;\n                throw new Error(\"Unexpected state status\", _never);\n            }\n        }\n    }\n    addKeyHandler(key, handler) {\n        if (this.keysHandlers.has(key)) {\n            const handlers = this.keysHandlers.get(key);\n            this.keysHandlers.set(key, [...handlers, handler]);\n        }\n        else {\n            this.keysHandlers.set(key, [handler]);\n        }\n    }\n    defineEventListeners() {\n        window.addEventListener(\"resize\", () => this.setDisplaySize());\n        window.addEventListener(\"keydown\", (e) => {\n            if (this.keysHandlers.has(e.key)) {\n                const handlers = this.keysHandlers.get(e.key);\n                handlers.forEach((h) => h(e));\n            }\n        });\n        this.trackedKeys = trackKeys([\n            ACTION_KEYS.moveLeft,\n            ACTION_KEYS.moveRight,\n            ACTION_KEYS.fire,\n        ]);\n    }\n    get canvasWidth() {\n        return this.canvas.width;\n    }\n    get canvasHeight() {\n        return this.canvas.height;\n    }\n    horPixels(percentage) {\n        return (percentage / 100) * this.canvasWidth;\n    }\n    verPixels(percentage) {\n        return (percentage / 100) * this.canvasHeight;\n    }\n    getPixelPos(percentagePos) {\n        return {\n            x: this.horPixels(percentagePos.x),\n            y: this.verPixels(percentagePos.y),\n        };\n    }\n    getPixelSize(percentageSize) {\n        return {\n            w: this.horPixels(percentageSize.w),\n            h: this.verPixels(percentageSize.h),\n        };\n    }\n    drawRunningGame(state, timeStep) {\n        this.drawPlayer(state.player);\n        this.drawAlienSet(state.alienSet);\n        this.drawBullets(state.bullets);\n        this.drawWalls(state.env.walls);\n        this.drawMetadata(state, timeStep);\n        if (state.boss !== null)\n            this.drawBoss(state.boss);\n        this.drawPressEscMessage();\n    }\n    drawAlienSet(alienSet) {\n        for (const alien of alienSet) {\n            if (!alien)\n                continue;\n            const xPercentage = alienSet.pos.x +\n                alien.gridPos.x * (DIMENSIONS.alienSetGap.w + DIMENSIONS.alien.w);\n            const yPercentage = alienSet.pos.y +\n                alien.gridPos.y * (DIMENSIONS.alienSetGap.h + DIMENSIONS.alien.h);\n            this.drawAlien(alien, {\n                x: xPercentage,\n                y: yPercentage,\n            });\n        }\n        const { x, y } = this.getPixelPos(alienSet.pos);\n        const { w, h } = this.getPixelSize(alienSet.size);\n        this.canvasContext.fillStyle = \"rgba(255,255,255,0.4)\";\n        this.canvasContext.fillRect(x, y, w, h);\n    }\n    drawAlien(alien, pos) {\n        const { w, h } = this.getPixelSize(DIMENSIONS.alien);\n        const { x, y } = this.getPixelPos(pos);\n        this.canvasContext.fillStyle = alienColors[alien.alienType];\n        this.canvasContext.fillRect(x, y, w, h);\n    }\n    drawBullets(bullets) {\n        for (const bullet of bullets) {\n            this.drawBullet(bullet);\n        }\n    }\n    drawBullet(bullet) {\n        const { x, y } = this.getPixelPos(bullet.pos);\n        const { w, h } = this.getPixelSize(bullet.size);\n        this.canvasContext.fillStyle =\n            bullet.from === \"alien\" ? \"limegreen\" : \"white\";\n        this.canvasContext.fillRect(x, y, w, h);\n    }\n    drawPlayer(player) {\n        const { x, y } = this.getPixelPos(player.pos);\n        const { w, h } = this.getPixelSize(DIMENSIONS.player);\n        this.canvasContext.fillStyle = \"white\";\n        this.canvasContext.fillRect(x, y, w, h);\n        this.drawPlayerGunReloadVisualClue(player);\n    }\n    drawBoss(boss) {\n        const { x, y } = this.getPixelPos(boss.pos);\n        const { w, h } = this.getPixelSize(DIMENSIONS.boss);\n        this.canvasContext.fillStyle = \"#f77\";\n        this.canvasContext.fillRect(x, y, w, h);\n    }\n    drawPlayerGunReloadVisualClue(player) {\n        const { gun, pos } = player;\n        const extraWidth = DIMENSIONS.player.w * 0.15;\n        const gap = DIMENSIONS.player.h * 0.1;\n        const clueHeight = 1, clueWidth = DIMENSIONS.player.w + extraWidth, cluePixelsHeight = this.verPixels(clueHeight), cluePixelsWidth = this.horPixels(clueWidth);\n        const x = pos.x - extraWidth / 2, y = pos.y + DIMENSIONS.player.h + gap, xPixels = this.horPixels(x), yPixels = this.verPixels(y);\n        const loadedPercentage = Math.min(1, gun.timeSinceLastShot / gun.fireInterval);\n        this.canvasContext.save();\n        this.canvasContext.translate(xPixels, yPixels);\n        this.canvasContext.fillStyle = \"#0f0\";\n        this.canvasContext.fillRect(0 - extraWidth / 2, 0, loadedPercentage * cluePixelsWidth, cluePixelsHeight);\n        this.canvasContext.fillStyle = \"#999\";\n        this.canvasContext.fillRect(loadedPercentage * cluePixelsWidth - extraWidth / 2, 0, cluePixelsWidth - loadedPercentage * cluePixelsWidth, cluePixelsHeight);\n        this.canvasContext.restore();\n    }\n    drawWalls(walls) {\n        for (const wall of walls) {\n            this.drawWall(wall);\n        }\n    }\n    drawWall(wall) {\n        const { x, y } = this.getPixelPos(wall.pos);\n        this.canvasContext.save();\n        this.canvasContext.translate(x, y);\n        const { w, h } = wall.pieceSize;\n        const piecePixelWidth = this.horPixels(w), piecePixelHeight = this.verPixels(h);\n        for (const { row, column, piece } of wall) {\n            if (piece) {\n                const xPixels = this.horPixels(column * w), yPixels = this.verPixels(row * h);\n                this.canvasContext.fillStyle = \"#ffffff\";\n                this.canvasContext.fillRect(xPixels, yPixels, piecePixelWidth, piecePixelHeight);\n            }\n        }\n        this.canvasContext.restore();\n    }\n    drawMetadata(state, timeStep) {\n        const fontSize = Math.min(30, this.verPixels(6));\n        const yPixelsPadding = this.verPixels(MODEL_LAYOUT.padding.ver);\n        this.canvasContext.fillStyle = \"#fff\";\n        this.canvasContext.font = `${fontSize}px ${this.canvasFontFamily}`;\n        this.canvasContext.textAlign = \"start\";\n        this.canvasContext.fillText(`SCORE ${state.player.score}`, this.horPixels(MODEL_LAYOUT.padding.hor), fontSize + yPixelsPadding);\n        this.canvasContext.textAlign = \"end\";\n        this.canvasContext.fillText(`Lives ${state.player.lives}`, this.horPixels(100 - MODEL_LAYOUT.padding.hor), fontSize + yPixelsPadding);\n        const fps = Math.round(1 / timeStep);\n        this.canvasContext.textAlign = \"center\";\n        this.canvasContext.fillText(`${fps} FPS`, this.horPixels(50), fontSize + yPixelsPadding);\n    }\n    drawInitialScreen() {\n        this.drawTitle();\n        this.drawTwinkleMessage(\"Press space to start\");\n    }\n    drawTitle() {\n        const fontSize = Math.min(65, this.horPixels(15));\n        this.canvasContext.font = `${fontSize}px ${this.canvasFontFamily}`;\n        const xPixelPos = this.horPixels(50), yPixelPos = this.verPixels(30);\n        this.canvasContext.fillStyle = \"white\";\n        this.canvasContext.textAlign = \"center\";\n        this.canvasContext.fillText(\"SPACE\", xPixelPos, yPixelPos);\n        this.canvasContext.fillText(\"INVADERS\", xPixelPos, yPixelPos + fontSize);\n    }\n    drawTwinkleMessage(message) {\n        if (Math.round(performance.now() / 800) % 2 === 0) {\n            const fontSize = Math.min(30, this.horPixels(6));\n            this.canvasContext.font = `${fontSize}px ${this.canvasFontFamily}`;\n            this.canvasContext.textAlign = \"center\";\n            this.canvasContext.fillStyle = \"#fff\";\n            const xPixelPos = this.horPixels(50), yPixelPos = this.verPixels(75);\n            this.canvasContext.fillText(message, xPixelPos, yPixelPos);\n        }\n    }\n    drawGameOverScreen() {\n        const fontSize = Math.min(65, this.horPixels(10));\n        const xPixelPos = this.horPixels(50), yPixelPos = this.verPixels(30);\n        this.canvasContext.font = `${fontSize}px ${this.canvasFontFamily}`;\n        this.canvasContext.fillStyle = \"#f66\";\n        this.canvasContext.textAlign = \"center\";\n        this.canvasContext.fillText(\"GAME\", xPixelPos, yPixelPos);\n        this.canvasContext.fillText(\"OVER\", xPixelPos, yPixelPos + fontSize);\n        this.drawTwinkleMessage(\"Press space to play again\");\n    }\n    drawPressEscMessage() {\n        const fontSize = Math.min(18, this.horPixels(2));\n        const xPixelPos = this.horPixels(MODEL_LAYOUT.padding.hor), yPixelPos = this.verPixels(12);\n        this.canvasContext.font = `${fontSize}px ${this.canvasFontFamily}`;\n        this.canvasContext.fillStyle = \"#fff\";\n        this.canvasContext.textAlign = \"left\";\n        this.canvasContext.fillText('Press \"Esc\" to pause/unpause', xPixelPos, yPixelPos);\n    }\n}\nclass GamePresenter {\n    constructor(State, View) {\n        this.paused = false;\n        this.State = State;\n        this.state = State.start(basicInvaderPlan);\n        this.view = new View(this.state, this, document.body);\n        this.view.syncState(this.state, 0);\n        this.runGame();\n        this.addEventHandlers();\n    }\n    addEventHandlers() {\n        this.view.addKeyHandler(ACTION_KEYS.pauseGame, this.handlePause.bind(this));\n        this.view.addKeyHandler(ACTION_KEYS.startGame, this.handleStartGame.bind(this));\n        this.view.addKeyHandler(ACTION_KEYS.restartGame, this.handleRestartGame.bind(this));\n    }\n    handlePause(e) {\n        e.preventDefault();\n        if (this.state.status !== \"running\")\n            return;\n        if (this.paused) {\n            this.paused = false;\n            this.runGame();\n        }\n        else {\n            this.paused = true;\n        }\n    }\n    handleStartGame(e) {\n        e.preventDefault();\n        if (this.state.status === \"start\") {\n            this.state.status = \"running\";\n        }\n    }\n    handleRestartGame(e) {\n        e.preventDefault();\n        if (this.state.status === \"lost\") {\n            this.state = this.State.start(basicInvaderPlan);\n            this.state.status = \"running\";\n        }\n    }\n    runGame() {\n        runAnimation((timeStep) => this.frame(timeStep));\n    }\n    frame(timeStep) {\n        if (this.paused && this.state.status === \"running\")\n            return false;\n        this.state.update(timeStep, this.view.trackedKeys);\n        this.view.syncState(this.state, timeStep);\n        return true;\n    }\n}\nnew GamePresenter(GameState, CanvasView);\n\n\n//# sourceURL=webpack://space-invaders/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;