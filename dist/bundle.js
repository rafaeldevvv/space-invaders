/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (() => {

eval("\nconst alienTypes = [\"X\", \"Y\", \"Z\"];\nconst alienTypesRegExp = new RegExp(`(\\\\w*(${alienTypes.join(\"|\")})*\\\\w*)+`);\nconst DIMENSIONS = {\n    alien: {\n        w: 3.5,\n        h: 5,\n    },\n    player: {\n        w: 4,\n        h: 6,\n    },\n    alienSetGap: {\n        w: 1,\n        h: 1.5,\n    },\n    boss: {\n        w: 7,\n        h: 7.5,\n    },\n};\nconst LAYOUT = {\n    padding: {\n        hor: 3,\n        ver: 3,\n    },\n    numWalls: 4,\n    wallsSize: {\n        w: 12,\n        h: 10,\n    },\n    playerYPos: 90,\n};\nconst ACTION_KEYS = {\n    moveRight: \"ArrowRight\",\n    moveLeft: \"ArrowLeft\",\n    fire: \" \",\n    startGame: \" \",\n    restartGame: \" \",\n    pauseGame: \"Escape\",\n};\nconst BOSS_CONFIG = {\n    yPos: 6,\n    speedX: 13,\n    baseAppearanceInterval: 25,\n    score: 200,\n};\nconst alienTypesConfig = {\n    X: {\n        score: 10,\n        gunConfig: [40, { w: 0.5, h: 3 }, 20000],\n    },\n    Y: {\n        score: 20,\n        gunConfig: [60, { w: 1, h: 3 }, 30000],\n    },\n    Z: {\n        score: 30,\n        gunConfig: [80, { w: 1.5, h: 3 }, 40000],\n    },\n};\nconst aliensPlan = `\r\nZZZZZZZZZZ\r\nYYYYYYYYYY\r\nYYYYYYYYYY\r\nXXXXXXXXXX\r\nXXXXXXXXXX\r\n`;\nconst customWall1 = `\r\n........######################################........\r\n.....############################################.....\r\n...################################################...\r\n..##################################################..\r\n.###################################################..\r\n.############.......##############.......############.\r\n.##########...........##########...........##########.\r\n##########..............######..............##########\r\n#########......##........####.........##.....#########\r\n########......##..........##...........##....#########\r\n########......##.........####..........##.....########\r\n########......###......#########......###.....########\r\n########.......#####..####..######..####......########\r\n########........########......########........########\r\n########.........#####..........#####.........########\r\n#########....................................#########\r\n.#########..................................#########.\r\n..##########..............................##########..\r\n`;\nconst customWall2 = `\r\n...#...............................................#...\r\n..###.............................................###..\r\n..####...........................................####..\r\n.######....................#....................######.\r\n.#######..................###..................#######.\r\n#########................#####................#########\r\n##########..............#######..............##########\r\n############.........#############.........############\r\n##############..#..#################..#..##############\r\n#######################################################\r\n.#####################################################.\r\n...#################################################...\r\n......###########################################......\r\n........###########..................##########........\r\n..........#######......................#######.........\r\n`;\nconst customWall3 = `\r\n............######################################............\r\n.........############################################.........\r\n.......################################################.......\r\n......##################################################......\r\n....####################################################......\r\n....######################################################....\r\n....######################################################....\r\n....######################################################....\r\n....######################################################....\r\n....######################################################....\r\n....######################################################....\r\n....######################################################....\r\n....#############............................#############....\r\n....############..............................############....\r\n....###########................................###########....\r\n...###########..................................###########...\r\n...###########..................................###########...\r\n..#############................................#############..\r\n.###############..............................###############.\r\n##################..........................##################\r\n`;\nclass Vector {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    plus(other) {\n        return new Vector(this.x + other.x, this.y + other.y);\n    }\n    minus(other) {\n        return new Vector(this.x - other.x, this.y - other.y);\n    }\n    times(factor) {\n        return new Vector(this.x * factor, this.y * factor);\n    }\n}\nfunction runAnimation(callback) {\n    let lastTime = null;\n    function frame(time) {\n        let shouldContinue;\n        if (lastTime) {\n            const timeStep = Math.min(time - lastTime, 100) / 1000;\n            lastTime = time;\n            shouldContinue = callback(timeStep);\n        }\n        else {\n            lastTime = time;\n            shouldContinue = true;\n        }\n        if (shouldContinue)\n            requestAnimationFrame(frame);\n    }\n    requestAnimationFrame(frame);\n}\nfunction randomNum(min, max) {\n    return min + Math.random() * (max - min);\n}\nfunction overlap(pos1, size1, pos2, size2) {\n    return (pos1.x + size1.w > pos2.x &&\n        pos1.x < pos2.x + size2.w &&\n        pos1.y + size1.h > pos2.y &&\n        pos1.y < pos2.y + size2.h);\n}\nfunction getElementInnerDimensions(element) {\n    const cs = getComputedStyle(element);\n    const paddingY = parseFloat(cs.paddingBlockStart) + parseFloat(cs.paddingBlockEnd);\n    const paddingX = parseFloat(cs.paddingInlineStart) + parseFloat(cs.paddingInlineEnd);\n    const marginY = parseFloat(cs.marginBlockStart) + parseFloat(cs.marginBlockEnd);\n    const marginX = parseFloat(cs.marginInlineStart) + parseFloat(cs.marginInlineEnd);\n    return {\n        w: element.offsetWidth - paddingX - marginX,\n        h: element.offsetHeight - paddingY - marginY,\n    };\n}\nfunction trackKeys(keys) {\n    const down = {};\n    keys.forEach((key) => (down[key] = false));\n    function onPressKey(e) {\n        for (const key of keys) {\n            if (e.key === key) {\n                e.preventDefault();\n                down[e.key] = e.type === \"keydown\";\n            }\n        }\n    }\n    window.addEventListener(\"keydown\", onPressKey);\n    window.addEventListener(\"keyup\", onPressKey);\n    return down;\n}\nfunction isColumnDead(rows, column) {\n    return rows.every((row) => row[column] === null);\n}\nfunction isRowDead(row) {\n    return row.every((alien) => alien === null);\n}\nfunction getFirstOrLastColumnIfDead(rows) {\n    const isFirstColumnDead = isColumnDead(rows, 0);\n    const isLastColumnDead = isColumnDead(rows, rows[0].length - 1);\n    if (isFirstColumnDead)\n        return 0;\n    if (isLastColumnDead)\n        return rows[0].length - 1;\n    else\n        return null;\n}\nfunction getFirstOrLastRowIfDead(rows) {\n    const isFirstRowDead = isRowDead(rows[0]);\n    const isLastRowDead = isRowDead(rows[rows.length - 1]);\n    if (isFirstRowDead)\n        return 0;\n    if (isLastRowDead)\n        return rows.length - 1;\n    else\n        return null;\n}\nfunction randomNumberInFactorRange(n, subtractingFactor, addingFactor = subtractingFactor) {\n    return randomNum((1 - subtractingFactor) * n, (1 + addingFactor) * n);\n}\nconst alienSetStepToEdgeAdjustment = 1.33;\nconst alienSetTimeDecreaseFactor = 0.92;\nvar HorizontalDirection;\n(function (HorizontalDirection) {\n    HorizontalDirection[HorizontalDirection[\"Right\"] = 1] = \"Right\";\n    HorizontalDirection[HorizontalDirection[\"Left\"] = -1] = \"Left\";\n})(HorizontalDirection || (HorizontalDirection = {}));\nclass AlienSet {\n    constructor(plan) {\n        this.yStep = 3;\n        this.timeToUpdate = 1;\n        this.direction = 1;\n        this.timeStepSum = 0;\n        if (!alienTypesRegExp.test(plan)) {\n            throw new Error(`Invalid character(s) in plan ${plan}. Consider using only valid characters (${alienTypes.join(\",\")})`);\n        }\n        const rows = plan\n            .trim()\n            .split(\"\\n\")\n            .map((l) => [...l]);\n        this.numColumns = rows[0].length;\n        this.numRows = rows.length;\n        this.alive = this.numColumns * this.numRows;\n        const w = this.numColumns * DIMENSIONS.alien.w +\n            (this.numColumns - 1) * DIMENSIONS.alienSetGap.w;\n        const h = this.numRows * DIMENSIONS.alien.h +\n            (this.numRows - 1) * DIMENSIONS.alienSetGap.h;\n        this.size = { w, h };\n        this.pos = new Vector(50 - w / 2, LAYOUT.padding.ver + 12);\n        this.xStep = (100 - LAYOUT.padding.hor * 2 - w) / 15;\n        this.aliens = rows.map((row, y) => {\n            return row.map((ch, x) => {\n                return Alien.create(ch, { x, y });\n            });\n        });\n    }\n    update(timeStep) {\n        this.timeStepSum += timeStep;\n        const movedY = this.moveVertically();\n        const movedX = this.moveHorizontally(movedY);\n        if (this.timeStepSum >= this.timeToUpdate) {\n            this.timeStepSum = 0;\n        }\n        if (movedY > 0) {\n            this.timeToUpdate *= alienSetTimeDecreaseFactor;\n        }\n        this.pos = this.pos.plus(new Vector(movedX, movedY));\n        for (const alien of this) {\n            if (alien)\n                alien.gun.update(timeStep);\n        }\n    }\n    moveVertically() {\n        let movedY = 0;\n        if (this.pos.x + this.size.w >= 100 - LAYOUT.padding.hor &&\n            this.timeStepSum >= this.timeToUpdate &&\n            this.direction === HorizontalDirection.Right) {\n            movedY = this.yStep;\n            this.direction = HorizontalDirection.Left;\n        }\n        else if (this.pos.x <= LAYOUT.padding.hor &&\n            this.timeStepSum >= this.timeToUpdate &&\n            this.direction === HorizontalDirection.Left) {\n            movedY = this.yStep;\n            this.direction = HorizontalDirection.Right;\n        }\n        return movedY;\n    }\n    moveHorizontally(movedY) {\n        let movedX = 0;\n        if (this.timeStepSum >= this.timeToUpdate && movedY === 0) {\n            if (this.direction === HorizontalDirection.Right) {\n                const rightDistance = 100 - this.pos.x - LAYOUT.padding.hor - this.size.w;\n                if (rightDistance < this.xStep * alienSetStepToEdgeAdjustment) {\n                    movedX = rightDistance;\n                }\n                else {\n                    movedX = this.xStep;\n                }\n            }\n            else {\n                const leftDistance = this.pos.x - LAYOUT.padding.hor;\n                if (leftDistance < this.xStep * alienSetStepToEdgeAdjustment) {\n                    movedX = leftDistance;\n                }\n                else {\n                    movedX = this.xStep;\n                }\n            }\n            movedX *= this.direction;\n        }\n        return movedX;\n    }\n    adapt() {\n        this.adaptPos();\n        this.adaptSize();\n        this.removeDeadRowsAndColumns();\n    }\n    adaptSize() {\n        let firstLivingAlienRow = null, lastLivingAlienRow = null, firstLivingAlienColumn = null, lastLivingAlienColumn = null;\n        for (const alien of this) {\n            if (!alien)\n                continue;\n            const { x: column, y: row } = alien.gridPos;\n            if (firstLivingAlienRow === null) {\n                firstLivingAlienRow = row;\n            }\n            lastLivingAlienRow = row;\n            if (firstLivingAlienColumn === null || column < firstLivingAlienColumn) {\n                firstLivingAlienColumn = column;\n            }\n            if (lastLivingAlienColumn === null || column > lastLivingAlienColumn) {\n                lastLivingAlienColumn = column;\n            }\n        }\n        if (firstLivingAlienRow !== null) {\n            const newH = (lastLivingAlienRow - firstLivingAlienRow + 1) * DIMENSIONS.alien.h +\n                (lastLivingAlienRow - firstLivingAlienRow) * DIMENSIONS.alienSetGap.h;\n            const newW = (lastLivingAlienColumn - firstLivingAlienColumn + 1) *\n                DIMENSIONS.alien.w +\n                (lastLivingAlienColumn - firstLivingAlienColumn) *\n                    DIMENSIONS.alienSetGap.w;\n            this.size = {\n                w: newW,\n                h: newH,\n            };\n        }\n    }\n    adaptPos() {\n        let firstLivingAlienColumn = null;\n        let firstLivingAlienRow = null;\n        for (const alien of this) {\n            if (!alien)\n                continue;\n            const { x, y } = alien.gridPos;\n            if (firstLivingAlienColumn === null || x < firstLivingAlienColumn) {\n                firstLivingAlienColumn = x;\n            }\n            if (firstLivingAlienRow === null) {\n                firstLivingAlienRow = y;\n            }\n        }\n        if (firstLivingAlienColumn !== null && firstLivingAlienRow !== null) {\n            this.pos = this.getAlienPos({\n                x: firstLivingAlienColumn,\n                y: firstLivingAlienRow,\n            });\n        }\n    }\n    removeDeadRowsAndColumns() {\n        let columnToRemove;\n        while ((columnToRemove = getFirstOrLastColumnIfDead(this.aliens)) !== null) {\n            this.aliens = this.aliens.map((row) => {\n                return row.filter((_, x) => x !== columnToRemove);\n            });\n            this.syncAliensGridPos();\n        }\n        let rowToRemove;\n        while (this.aliens.length !== 0 &&\n            (rowToRemove = getFirstOrLastRowIfDead(this.aliens)) !== null) {\n            this.aliens = this.aliens.filter((_, y) => y !== rowToRemove);\n            this.syncAliensGridPos();\n        }\n        this.syncNumOfColsAndRows();\n    }\n    syncAliensGridPos() {\n        this.aliens.forEach((row, y) => {\n            row.forEach((alien, x) => {\n                if (alien)\n                    alien.gridPos = { x, y };\n            });\n        });\n    }\n    syncNumOfColsAndRows() {\n        this.numRows = this.aliens.length;\n        this.numColumns = this.numRows === 0 ? 0 : this.aliens[0].length;\n    }\n    getAlienPos({ x, y }) {\n        return new Vector(this.pos.x + x * DIMENSIONS.alien.w + x * DIMENSIONS.alienSetGap.w, this.pos.y + y * DIMENSIONS.alien.h + y * DIMENSIONS.alienSetGap.h);\n    }\n    removeAlien(alien) {\n        this.aliens[alien.gridPos.y][alien.gridPos.x] = null;\n        this.alive--;\n    }\n    *[Symbol.iterator]() {\n        for (let y = 0; y < this.numRows; y++) {\n            for (let x = 0; x < this.numColumns; x++) {\n                yield this.aliens[y][x];\n            }\n        }\n    }\n}\nclass Alien {\n    constructor(gridPos, score, gun, alienType) {\n        this.gridPos = gridPos;\n        this.score = score;\n        this.gun = gun;\n        this.alienType = alienType;\n        this.actorType = \"alien\";\n    }\n    fire(alienPos) {\n        const bulletX = alienPos.x + DIMENSIONS.alien.w / 2 - this.gun.bulletSize.w / 2;\n        return this.gun.fire(new Vector(bulletX, alienPos.y), \"down\");\n    }\n    static create(ch, gridPos) {\n        if (ch === \".\") {\n            return null;\n        }\n        else {\n            const { score, gunConfig } = alienTypesConfig[ch];\n            return new Alien(gridPos, score, new Gun(\"alien\", ...gunConfig), ch);\n        }\n    }\n}\nclass Boss {\n    constructor() {\n        this.direction = Math.random() > 0.5 ? 1 : -1;\n        if (this.direction === HorizontalDirection.Left) {\n            this.pos = new Vector(100, BOSS_CONFIG.yPos);\n        }\n        else {\n            this.pos = new Vector(-DIMENSIONS.boss.w, BOSS_CONFIG.yPos);\n        }\n    }\n    update(timeStep) {\n        this.pos = this.pos.plus(new Vector(this.direction * BOSS_CONFIG.speedX * timeStep, 0));\n    }\n    isOutOfBounds() {\n        if (this.direction === HorizontalDirection.Right) {\n            return this.pos.x >= 100;\n        }\n        else {\n            return this.pos.x <= -DIMENSIONS.boss.w;\n        }\n    }\n}\nconst playerXSpeed = 30;\nclass Player {\n    constructor() {\n        this.actorType = \"player\";\n        this.baseXPos = 50 - DIMENSIONS.player.w / 2;\n        this.pos = new Vector(this.baseXPos, LAYOUT.playerYPos);\n        this.gun = new Gun(\"player\", 70, { w: 0.5, h: 3 }, 0);\n        this.lives = 3;\n        this.score = 0;\n    }\n    fire() {\n        const bulletPosX = this.pos.x + DIMENSIONS.player.w / 2 - this.gun.bulletSize.w / 2;\n        return this.gun.fire(new Vector(bulletPosX, this.pos.y), \"up\");\n    }\n    resetPos() {\n        this.pos = new Vector(this.baseXPos, LAYOUT.playerYPos);\n    }\n    update(state, timeStep, keys) {\n        const movedX = new Vector(timeStep * playerXSpeed, 0);\n        if (keys[ACTION_KEYS.moveLeft] && this.pos.x > LAYOUT.padding.hor) {\n            this.pos = this.pos.minus(movedX);\n        }\n        else if (keys[ACTION_KEYS.moveRight] &&\n            this.pos.x + DIMENSIONS.player.w < 100 - LAYOUT.padding.hor) {\n            this.pos = this.pos.plus(movedX);\n        }\n        if (keys[ACTION_KEYS.fire] && !state.isPlayerBulletPresent) {\n            state.bullets.push(this.fire());\n            state.isPlayerBulletPresent = true;\n        }\n    }\n}\nclass Gun {\n    constructor(owner, bulletSpeed, bulletSize, baseFireInterval) {\n        this.owner = owner;\n        this.bulletSpeed = bulletSpeed;\n        this.bulletSize = bulletSize;\n        this.baseFireInterval = baseFireInterval;\n        this.timeSinceLastShot = 0;\n        this.fireInterval = randomNumberInFactorRange(baseFireInterval, 0.2);\n        this.timeSinceLastShot = randomNum(0, this.fireInterval);\n    }\n    fire(pos, direction) {\n        const bullet = new Bullet(this.owner, pos, new Vector(0, direction === \"up\" ? -this.bulletSpeed : this.bulletSpeed), this.bulletSize);\n        if (this.baseFireInterval === 0) {\n            return bullet;\n        }\n        if (this.canFire()) {\n            this.timeSinceLastShot = 0;\n            this.fireInterval = randomNumberInFactorRange(this.baseFireInterval, 0.2);\n            return bullet;\n        }\n        return null;\n    }\n    update(timeStep) {\n        this.timeSinceLastShot += timeStep * 1000;\n    }\n    canFire() {\n        if (this.baseFireInterval === 0)\n            return true;\n        return this.timeSinceLastShot >= this.fireInterval;\n    }\n}\nclass Bullet {\n    constructor(from, pos, speed, size) {\n        this.from = from;\n        this.pos = pos;\n        this.speed = speed;\n        this.size = size;\n    }\n    update(timeStep) {\n        this.pos = this.pos.plus(this.speed.times(timeStep));\n    }\n    collide(state) {\n        state.bullets = state.bullets.filter((bullet) => bullet !== this);\n    }\n}\nclass Wall {\n    constructor(pos, size, numColumnsOrPlan, numRows) {\n        this.pos = pos;\n        this.size = size;\n        let pieces;\n        let pieceSize;\n        if (typeof numColumnsOrPlan === \"string\") {\n            pieces = numColumnsOrPlan\n                .trim()\n                .split(\"\\n\")\n                .map((row) => [...row].map((ch) => ch === \"#\"));\n            pieceSize = {\n                w: this.size.w / pieces[0].length,\n                h: this.size.h / pieces.length,\n            };\n        }\n        else {\n            pieces = new Array(numRows)\n                .fill(undefined)\n                .map(() => new Array(numColumnsOrPlan).fill(true));\n            pieceSize = {\n                w: size.w / numColumnsOrPlan,\n                h: size.h / numRows,\n            };\n        }\n        this.pieceSize = pieceSize;\n        this.piecesMatrix = pieces;\n    }\n    getPiecePos(column, row) {\n        return {\n            x: this.pos.x + column * this.pieceSize.w,\n            y: this.pos.y + row * this.pieceSize.h,\n        };\n    }\n    collide(objPos, objSize) {\n        if (!overlap(this.pos, this.size, objPos, objSize))\n            return false;\n        let touchedPiece = false;\n        for (const { row, column, piece } of this) {\n            if (!piece)\n                continue;\n            const piecePos = this.getPiecePos(column, row);\n            if (overlap(objPos, objSize, piecePos, this.pieceSize)) {\n                this.piecesMatrix[row][column] = false;\n                if (!touchedPiece)\n                    touchedPiece = true;\n            }\n        }\n        return touchedPiece;\n    }\n    *[Symbol.iterator]() {\n        const rows = this.piecesMatrix.length;\n        for (let row = 0; row < rows; row++) {\n            const columnLength = this.piecesMatrix[row].length;\n            for (let column = 0; column < columnLength; column++) {\n                const piece = this.piecesMatrix[row][column];\n                yield { row, column, piece };\n            }\n        }\n    }\n}\nclass GameEnv {\n    constructor(alienSet, player, walls) {\n        this.alienSet = alienSet;\n        this.player = player;\n        this.walls = walls;\n    }\n    isBulletOutOfBounds(bullet) {\n        return bullet.pos.y >= 100 || bullet.pos.y + bullet.size.h <= 0;\n    }\n    alienSetTouchesPlayer() {\n        return this.alienSet.pos.y + this.alienSet.size.h >= this.player.pos.y;\n    }\n    bulletTouchesObject(bullet, objPos, objSize) {\n        return overlap(bullet.pos, bullet.size, objPos, objSize);\n    }\n    handleAlienSetContactWithWall() {\n        for (const wall of this.walls) {\n            for (const alien of this.alienSet) {\n                if (alien === null)\n                    continue;\n                const alienPos = this.alienSet.getAlienPos(alien.gridPos);\n                wall.collide(alienPos, DIMENSIONS.alien);\n            }\n        }\n        return false;\n    }\n}\nfunction generateRandomBossAppearanceInterval() {\n    return randomNum(0.8 * BOSS_CONFIG.baseAppearanceInterval, 1.2 * BOSS_CONFIG.baseAppearanceInterval);\n}\nclass GameState {\n    constructor(alienSet, player, env) {\n        this.alienSet = alienSet;\n        this.player = player;\n        this.env = env;\n        this.bullets = [];\n        this.status = \"start\";\n        this.boss = null;\n        this.bossesKilled = 0;\n        this.aliensKilled = 0;\n        this.isPlayerBulletPresent = false;\n        this.timeSinceBossLastAppearance = 0;\n        this.bossAppearanceInterval = generateRandomBossAppearanceInterval();\n    }\n    update(timeStep, keys) {\n        if (this.status !== \"running\")\n            return;\n        this.alienSet.update(timeStep);\n        this.player.update(this, timeStep, keys);\n        this.fireAliens();\n        this.handleBullets(timeStep);\n        this.handleBoss(timeStep);\n        this.env.handleAlienSetContactWithWall();\n        if (this.alienSet.alive === 0) {\n            this.alienSet = new AlienSet(aliensPlan);\n            this.env.alienSet = this.alienSet;\n            this.player.lives++;\n        }\n        else if (this.player.lives < 1 || this.env.alienSetTouchesPlayer()) {\n            this.status = \"lost\";\n        }\n    }\n    handleBullets(timeStep) {\n        this.bullets.forEach((bullet) => bullet.update(timeStep));\n        const newBullets = [];\n        let isSomeAlienKilled = false;\n        for (const b of this.bullets) {\n            const outOfBounds = this.env.isBulletOutOfBounds(b);\n            if (outOfBounds) {\n                if (b.from === \"player\")\n                    this.isPlayerBulletPresent = false;\n                continue;\n            }\n            if (b.from === \"alien\") {\n                const touchedPlayer = this.handleBulletContactWithPlayer(b);\n                if (touchedPlayer)\n                    continue;\n            }\n            else {\n                const touchedAlien = this.handleBulletContactWithAlien(b);\n                const touchedBoss = this.handleBulletContactWithBoss(b);\n                if (!isSomeAlienKilled)\n                    isSomeAlienKilled = touchedAlien;\n                if (touchedAlien || touchedBoss) {\n                    this.isPlayerBulletPresent = false;\n                    continue;\n                }\n            }\n            const touchedWall = this.handleBulletContactWithWalls(b);\n            if (touchedWall) {\n                if (b.from === \"player\")\n                    this.isPlayerBulletPresent = false;\n                continue;\n            }\n            newBullets.push(b);\n        }\n        if (isSomeAlienKilled)\n            this.alienSet.adapt();\n        this.bullets = newBullets;\n    }\n    handleBulletContactWithPlayer(b) {\n        if (this.env.bulletTouchesObject(b, this.player.pos, DIMENSIONS.player)) {\n            this.player.lives--;\n            this.player.resetPos();\n            return true;\n        }\n        return false;\n    }\n    handleBulletContactWithAlien(b) {\n        for (const alien of this.alienSet) {\n            if (alien === null)\n                continue;\n            const alienPos = this.alienSet.getAlienPos(alien.gridPos);\n            if (this.env.bulletTouchesObject(b, alienPos, DIMENSIONS.alien)) {\n                this.player.score += alien.score;\n                this.aliensKilled++;\n                this.alienSet.removeAlien(alien);\n                return true;\n            }\n        }\n        return false;\n    }\n    handleBulletContactWithWalls(b) {\n        let touchedPiece = false;\n        for (const wall of this.env.walls) {\n            touchedPiece = wall.collide(b.pos, b.size);\n            if (touchedPiece)\n                break;\n        }\n        return touchedPiece;\n    }\n    handleBulletContactWithBoss(b) {\n        if (this.boss === null)\n            return false;\n        if (this.env.bulletTouchesObject(b, this.boss.pos, DIMENSIONS.boss)) {\n            this.player.score += BOSS_CONFIG.score;\n            this.boss = null;\n            this.bossesKilled++;\n            this.bossAppearanceInterval = generateRandomBossAppearanceInterval();\n            return true;\n        }\n    }\n    fireAliens() {\n        const newBullets = [];\n        for (const alien of this.alienSet) {\n            if (!alien)\n                continue;\n            if (alien.gun.canFire()) {\n                const alienPos = this.alienSet.getAlienPos(alien.gridPos);\n                const b = alien.fire(alienPos);\n                newBullets.push(b);\n            }\n        }\n        this.bullets.push(...newBullets);\n    }\n    handleBoss(timeStep) {\n        if (this.boss !== null)\n            this.boss.update(timeStep);\n        else\n            this.timeSinceBossLastAppearance += timeStep;\n        if (this.timeSinceBossLastAppearance >= this.bossAppearanceInterval) {\n            this.boss = new Boss();\n            this.timeSinceBossLastAppearance = 0;\n        }\n        if (this.boss && this.boss.isOutOfBounds()) {\n            this.boss = null;\n        }\n    }\n    static start(plan) {\n        const alienSet = new AlienSet(plan);\n        const player = new Player();\n        const gap = (100 - LAYOUT.wallsSize.w * LAYOUT.numWalls) / 5;\n        const walls = new Array(LAYOUT.numWalls)\n            .fill(undefined)\n            .map((_, i) => {\n            return new Wall({ x: (i + 1) * gap + LAYOUT.wallsSize.w * i, y: 75 }, LAYOUT.wallsSize, customWall3);\n        });\n        const env = new GameEnv(alienSet, player, walls);\n        return new GameState(alienSet, player, env);\n    }\n}\nconst alienColors = {\n    X: \"limegreen\",\n    Y: \"orange\",\n    Z: \"pink\",\n};\nconst GAME_DISPLAY_SETTINGS = {\n    maxWidth: 920,\n    aspectRatio: 4 / 3,\n};\nconst fontSizes = {\n    sm: 2.5,\n    md: 4,\n    lg: 6,\n    xl: 10,\n};\nclass CanvasView {\n    constructor(state, controller, parent) {\n        this.state = state;\n        this.controller = controller;\n        this.parent = parent;\n        this.canvasFontFamily = \"monospace\";\n        this.trackedKeys = {};\n        this.keysHandlers = new Map();\n        this.canvas = document.createElement(\"canvas\");\n        this.canvasContext = this.canvas.getContext(\"2d\");\n        this.canvas.style.display = \"block\";\n        this.canvas.style.marginInline = \"auto\";\n        this.parent.appendChild(this.canvas);\n        this.defineEventListeners();\n        this.setDisplaySize();\n        this.syncState(state, 0);\n    }\n    setDisplaySize() {\n        let canvasWidth = Math.min(GAME_DISPLAY_SETTINGS.maxWidth, getElementInnerDimensions(this.canvas.parentNode).w);\n        let canvasHeight = canvasWidth / GAME_DISPLAY_SETTINGS.aspectRatio;\n        if (canvasHeight > innerHeight) {\n            canvasHeight = innerHeight;\n            canvasWidth = canvasHeight * GAME_DISPLAY_SETTINGS.aspectRatio;\n        }\n        this.canvas.setAttribute(\"width\", canvasWidth.toString());\n        this.canvas.setAttribute(\"height\", canvasHeight.toString());\n        this.syncState(this.state, 1 / 60);\n    }\n    syncState(state, timeStep) {\n        this.canvasContext.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n        this.canvasContext.fillStyle = \"black\";\n        this.canvasContext.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n        switch (state.status) {\n            case \"running\": {\n                this.drawRunningGame(state, timeStep);\n                break;\n            }\n            case \"paused\": {\n                this.drawRunningGame(state, timeStep);\n                this.drawPauseHint();\n                break;\n            }\n            case \"start\": {\n                this.drawInitialScreen();\n                break;\n            }\n            case \"lost\": {\n                this.drawGameOverScreen(state);\n                break;\n            }\n            default: {\n                const _never = state.status;\n                throw new Error(\"Unexpected state status\", _never);\n            }\n        }\n    }\n    addKeyHandler(key, handler) {\n        if (this.keysHandlers.has(key)) {\n            const handlers = this.keysHandlers.get(key);\n            this.keysHandlers.set(key, [...handlers, handler]);\n        }\n        else {\n            this.keysHandlers.set(key, [handler]);\n        }\n    }\n    defineEventListeners() {\n        window.addEventListener(\"resize\", () => this.setDisplaySize());\n        window.addEventListener(\"keydown\", (e) => {\n            if (this.keysHandlers.has(e.key)) {\n                const handlers = this.keysHandlers.get(e.key);\n                handlers.forEach((h) => h(e));\n            }\n        });\n        this.trackedKeys = trackKeys([\n            ACTION_KEYS.moveLeft,\n            ACTION_KEYS.moveRight,\n            ACTION_KEYS.fire,\n        ]);\n    }\n    get canvasWidth() {\n        return this.canvas.width;\n    }\n    get canvasHeight() {\n        return this.canvas.height;\n    }\n    horPixels(percentage) {\n        return (percentage / 100) * this.canvasWidth;\n    }\n    verPixels(percentage) {\n        return (percentage / 100) * this.canvasHeight;\n    }\n    getPixelPos(percentagePos) {\n        return {\n            x: this.horPixels(percentagePos.x),\n            y: this.verPixels(percentagePos.y),\n        };\n    }\n    getPixelSize(percentageSize) {\n        return {\n            w: this.horPixels(percentageSize.w),\n            h: this.verPixels(percentageSize.h),\n        };\n    }\n    getFontSize(size) {\n        return this.horPixels(fontSizes[size]);\n    }\n    drawRunningGame(state, timeStep) {\n        this.drawPlayer(state.player);\n        this.drawAlienSet(state.alienSet);\n        this.drawBullets(state.bullets);\n        this.drawWalls(state.env.walls);\n        this.drawMetadata(state, timeStep);\n        if (state.boss !== null)\n            this.drawBoss(state.boss);\n        this.drawPressEscMessage();\n    }\n    drawAlienSet(alienSet) {\n        for (const alien of alienSet) {\n            if (!alien)\n                continue;\n            const xPercentage = alienSet.pos.x +\n                alien.gridPos.x * (DIMENSIONS.alienSetGap.w + DIMENSIONS.alien.w);\n            const yPercentage = alienSet.pos.y +\n                alien.gridPos.y * (DIMENSIONS.alienSetGap.h + DIMENSIONS.alien.h);\n            this.drawAlien(alien, {\n                x: xPercentage,\n                y: yPercentage,\n            });\n        }\n        const { x, y } = this.getPixelPos(alienSet.pos);\n        const { w, h } = this.getPixelSize(alienSet.size);\n        this.canvasContext.fillStyle = \"rgba(255,255,255,0.4)\";\n        this.canvasContext.fillRect(x, y, w, h);\n    }\n    drawAlien(alien, pos) {\n        const { w, h } = this.getPixelSize(DIMENSIONS.alien);\n        const { x, y } = this.getPixelPos(pos);\n        this.canvasContext.fillStyle = alienColors[alien.alienType];\n        this.canvasContext.fillRect(x, y, w, h);\n    }\n    drawBullets(bullets) {\n        for (const bullet of bullets) {\n            this.drawBullet(bullet);\n        }\n    }\n    drawBullet(bullet) {\n        const { x, y } = this.getPixelPos(bullet.pos);\n        const { w, h } = this.getPixelSize(bullet.size);\n        this.canvasContext.fillStyle =\n            bullet.from === \"alien\" ? \"limegreen\" : \"white\";\n        this.canvasContext.fillRect(x, y, w, h);\n    }\n    drawPlayer(player) {\n        const { x, y } = this.getPixelPos(player.pos);\n        const { w, h } = this.getPixelSize(DIMENSIONS.player);\n        this.canvasContext.fillStyle = \"white\";\n        this.canvasContext.fillRect(x, y, w, h);\n    }\n    drawBoss(boss) {\n        const { x, y } = this.getPixelPos(boss.pos);\n        const { w, h } = this.getPixelSize(DIMENSIONS.boss);\n        this.canvasContext.fillStyle = \"#f77\";\n        this.canvasContext.fillRect(x, y, w, h);\n    }\n    drawWalls(walls) {\n        for (const wall of walls) {\n            this.drawWall(wall);\n        }\n    }\n    drawWall(wall) {\n        const { x, y } = this.getPixelPos(wall.pos);\n        this.canvasContext.save();\n        this.canvasContext.translate(x, y);\n        const { w, h } = wall.pieceSize;\n        const piecePixelWidth = this.horPixels(w), piecePixelHeight = this.verPixels(h);\n        for (const { row, column, piece } of wall) {\n            if (piece) {\n                const xPixels = this.horPixels(column * w), yPixels = this.verPixels(row * h);\n                this.canvasContext.fillStyle = \"#ffffff\";\n                this.canvasContext.fillRect(xPixels, yPixels, piecePixelWidth, piecePixelHeight);\n            }\n        }\n        this.canvasContext.restore();\n    }\n    drawMetadata(state, timeStep) {\n        const fontSize = this.getFontSize(\"md\");\n        const yPixelsPadding = this.verPixels(LAYOUT.padding.ver);\n        this.canvasContext.fillStyle = \"#fff\";\n        this.canvasContext.textBaseline = \"top\";\n        this.canvasContext.font = `${fontSize}px ${this.canvasFontFamily}`;\n        this.canvasContext.textAlign = \"start\";\n        this.canvasContext.fillText(`SCORE ${state.player.score}`, this.horPixels(LAYOUT.padding.hor), yPixelsPadding);\n        this.canvasContext.textAlign = \"end\";\n        this.canvasContext.fillText(`Lives ${state.player.lives}`, this.horPixels(100 - LAYOUT.padding.hor), yPixelsPadding);\n        const fps = Math.round(1 / timeStep);\n        this.canvasContext.textAlign = \"center\";\n        this.canvasContext.fillText(`${fps} FPS`, this.horPixels(50), yPixelsPadding);\n    }\n    drawPauseHint() {\n        const hintWidth = this.horPixels(24), hintHeight = this.verPixels(10);\n        const hintXPos = this.horPixels(50) - hintWidth / 2, hintYPos = this.verPixels(50) - hintHeight / 2;\n        this.canvasContext.fillStyle = \"#fff\";\n        this.canvasContext.fillRect(hintXPos, hintYPos - 4, hintWidth, hintHeight);\n        const fontSize = this.getFontSize(\"lg\");\n        this.canvasContext.fillStyle = \"#000\";\n        this.canvasContext.font = `${fontSize}px ${this.canvasFontFamily}`;\n        this.canvasContext.textAlign = \"center\";\n        this.canvasContext.textBaseline = \"middle\";\n        this.canvasContext.fillText(\"PAUSED\", this.horPixels(50), this.verPixels(50));\n    }\n    drawInitialScreen() {\n        this.drawTitle();\n        this.drawTwinkleMessage(\"Press space to start\");\n    }\n    drawTitle() {\n        const fontSize = this.getFontSize(\"xl\");\n        this.canvasContext.font = `${fontSize}px ${this.canvasFontFamily}`;\n        const xPixelPos = this.horPixels(50), yPixelPos = this.verPixels(30);\n        this.canvasContext.fillStyle = \"white\";\n        this.canvasContext.textAlign = \"center\";\n        this.canvasContext.fillText(\"SPACE\", xPixelPos, yPixelPos);\n        this.canvasContext.fillText(\"INVADERS\", xPixelPos, yPixelPos + fontSize);\n    }\n    drawTwinkleMessage(message) {\n        if (Math.round(performance.now() / 800) % 2 === 0) {\n            const fontSize = this.getFontSize(\"md\");\n            this.canvasContext.font = `${fontSize}px ${this.canvasFontFamily}`;\n            this.canvasContext.textAlign = \"center\";\n            this.canvasContext.fillStyle = \"#fff\";\n            const xPixelPos = this.horPixels(50), yPixelPos = this.verPixels(75);\n            this.canvasContext.fillText(message, xPixelPos, yPixelPos);\n        }\n    }\n    drawGameOverScreen(state) {\n        const titleFontSize = this.getFontSize(\"xl\");\n        const { bossesKilled, aliensKilled, player: { score }, } = state;\n        const xPixelPos = this.horPixels(50), yPixelPos = this.verPixels(16);\n        this.canvasContext.font = `${titleFontSize}px ${this.canvasFontFamily}`;\n        this.canvasContext.fillStyle = \"#f77\";\n        this.canvasContext.textAlign = \"center\";\n        this.canvasContext.textBaseline = \"top\";\n        this.canvasContext.fillText(\"GAME\", xPixelPos, yPixelPos);\n        this.canvasContext.fillText(\"OVER\", xPixelPos, this.verPixels(27));\n        const subtitleFontSize = this.getFontSize(\"md\");\n        this.canvasContext.font = `${subtitleFontSize}px ${this.canvasFontFamily}`;\n        this.canvasContext.fillStyle = \"#fff\";\n        const aliens = aliensKilled === 1 ? \"alien\" : \"aliens\";\n        const bosses = bossesKilled === 1 ? \"boss\" : \"bosses\";\n        this.canvasContext.fillText(`You killed ${aliensKilled} ${aliens} and ${bossesKilled} ${bosses}`, this.horPixels(50), this.verPixels(50));\n        this.canvasContext.fillText(`Your score is ${score}`, this.horPixels(50), this.verPixels(57));\n        this.drawTwinkleMessage(\"Press space to play again\");\n    }\n    drawPressEscMessage() {\n        const fontSize = this.getFontSize(\"sm\");\n        const xPixelPos = this.horPixels(LAYOUT.padding.hor), yPixelPos = this.verPixels(8);\n        this.canvasContext.font = `${fontSize}px ${this.canvasFontFamily}`;\n        this.canvasContext.fillStyle = \"#fff\";\n        this.canvasContext.textAlign = \"left\";\n        this.canvasContext.textBaseline = \"top\";\n        this.canvasContext.fillText('Press \"Esc\" to pause/unpause', xPixelPos, yPixelPos);\n    }\n}\nclass GamePresenter {\n    constructor(State, View) {\n        this.State = State;\n        this.state = State.start(aliensPlan);\n        this.view = new View(this.state, this, document.body);\n        this.view.syncState(this.state, 0);\n        this.runGame();\n        this.addEventHandlers();\n    }\n    addEventHandlers() {\n        this.view.addKeyHandler(ACTION_KEYS.pauseGame, this.handlePause.bind(this));\n        this.view.addKeyHandler(ACTION_KEYS.startGame, this.handleStartGame.bind(this));\n        this.view.addKeyHandler(ACTION_KEYS.restartGame, this.handleRestartGame.bind(this));\n    }\n    handlePause(e) {\n        e.preventDefault();\n        if (this.state.status !== \"running\" && this.state.status !== \"paused\") {\n            return;\n        }\n        if (this.state.status === \"paused\") {\n            this.state.status = \"running\";\n            this.runGame();\n        }\n        else {\n            this.state.status = \"paused\";\n        }\n    }\n    handleStartGame(e) {\n        e.preventDefault();\n        if (this.state.status === \"start\") {\n            this.state.status = \"running\";\n        }\n    }\n    handleRestartGame(e) {\n        e.preventDefault();\n        if (this.state.status === \"lost\") {\n            this.state = this.State.start(aliensPlan);\n            this.state.status = \"running\";\n        }\n    }\n    runGame() {\n        runAnimation((timeStep) => this.frame(timeStep));\n    }\n    frame(timeStep) {\n        if (this.state.status === \"paused\") {\n            this.view.syncState(this.state, timeStep);\n            return false;\n        }\n        this.state.update(timeStep, this.view.trackedKeys);\n        this.view.syncState(this.state, timeStep);\n        return true;\n    }\n}\nnew GamePresenter(GameState, CanvasView);\n\n\n//# sourceURL=webpack://space-invaders/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.ts"]();
/******/ 	
/******/ })()
;